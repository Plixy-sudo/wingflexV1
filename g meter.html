<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird Clone</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            overflow: hidden;
            touch-action: none; /* Prevent scrolling on mobile */
            font-family: 'VT323', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }

        canvas {
            display: block;
            background-color: #70c5ce; /* Classic sky blue */
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 60px;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            margin: 0 0 10px 0;
            line-height: 1;
        }

        .score-board {
            background: #ded895;
            border: 4px solid #543847;
            padding: 20px;
            width: 200px;
            border-radius: 4px;
            margin-bottom: 20px;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
            position: relative;
        }

        .score-label {
            color: #e58d55;
            font-size: 24px;
            text-transform: uppercase;
            text-shadow: 1px 1px 0 #fff;
        }

        .score-value {
            color: #fff;
            font-size: 40px;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 10px;
        }

        .btn {
            pointer-events: auto;
            background: #e65f28;
            border: 2px solid #fff;
            color: white;
            font-family: 'VT323', monospace;
            font-size: 28px;
            padding: 10px 30px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #9e3c15;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #9e3c15;
        }

        #current-score {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 60px;
            color: white;
            text-shadow: 3px 3px 0 #000;
            z-index: 10;
            pointer-events: none;
        }

        /* Message box for desktop/mobile instructions */
        .instruction {
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            animation: bounce 1s infinite alternate;
        }
        
        .high-score-display {
            font-size: 20px;
            color: #f4c42e;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 10px;
        }

        .new-best-badge {
            position: absolute;
            top: -15px;
            right: -15px;
            background: #e74c3c;
            color: white;
            padding: 5px 10px;
            transform: rotate(15deg);
            border: 2px solid white;
            font-size: 18px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(10px); }
        }

        @keyframes pulse {
            from { transform: rotate(15deg) scale(1); }
            to { transform: rotate(15deg) scale(1.1); }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="current-score">0</div>

        <!-- Start Screen -->
        <div id="start-screen" class="overlay">
            <h1>FLAPPY<br>CLONE</h1>
            <div class="score-board" style="background: transparent; border: none; box-shadow: none;">
                <p class="high-score-display">High Score: <span id="start-high-score">0</span></p>
                <p class="instruction">Tap, Click, or Spacebar</p>
            </div>
            <button class="btn" onclick="startGame()">START</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="overlay hidden">
            <h1>GAME OVER</h1>
            <div class="score-board">
                <div id="new-best-badge" class="new-best-badge hidden">NEW BEST!</div>
                <div class="score-label">Score</div>
                <div id="final-score" class="score-value">0</div>
                <div class="score-label">Best</div>
                <div id="best-score" class="score-value">0</div>
            </div>
            <button class="btn" onclick="resetGame()">REPLAY</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('current-score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const bestScoreEl = document.getElementById('best-score');
        const startHighScoreEl = document.getElementById('start-high-score');
        const newBestBadge = document.getElementById('new-best-badge');

        // Game State
        let frames = 0;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('flappyHighScore')) || 0;
        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let gameSpeed = 3;

        // Sound Synth (No external files)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'jump') {
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'score') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        }

        // Setup Canvas Resolution (Portrait aspect ratio preferred)
        function resize() {
            let height = window.innerHeight;
            let width = Math.min(window.innerWidth, 480); // Cap width for mobile feel
            
            canvas.width = width;
            canvas.height = height;
            
            // ground Y position
            groundY = height - 100;
        }
        
        let groundY;
        resize();
        window.addEventListener('resize', resize);

        // Assets
        const bird = {
            x: 50,
            y: 150,
            w: 34,
            h: 24,
            velocity: 0,
            gravity: 0.25,
            jumpStrength: -5.5,
            rotation: 0,
            
            draw: function() {
                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                
                // Rotation based on velocity
                let rot = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
                ctx.rotate(rot);

                // Body
                ctx.fillStyle = '#f4c42e';
                ctx.fillRect(-17, -12, 34, 24);
                
                // Outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(-17, -12, 34, 24);

                // Eye
                ctx.fillStyle = '#fff';
                ctx.fillRect(6, -10, 10, 10);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, -6, 4, 4);

                // Beak
                ctx.fillStyle = '#e65f28';
                ctx.fillRect(6, 2, 14, 8);
                ctx.strokeRect(6, 2, 14, 8);

                // Wing
                ctx.fillStyle = '#fff';
                ctx.fillRect(-10, 0, 14, 8);
                ctx.strokeRect(-10, 0, 14, 8);

                ctx.restore();
            },

            update: function() {
                this.velocity += this.gravity;
                this.y += this.velocity;

                // Floor Collision
                if (this.y + this.h >= groundY) {
                    this.y = groundY - this.h;
                    gameOver();
                }
                
                // Ceiling collision
                if (this.y < 0) {
                    this.y = 0;
                    this.velocity = 0;
                }
            },

            jump: function() {
                this.velocity = this.jumpStrength;
                playSound('jump');
            }
        };

        const pipes = {
            items: [],
            w: 52,
            gap: 140, // Slightly easier gap
            dx: 3,
            
            draw: function() {
                for(let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    
                    // Pipe Color
                    ctx.fillStyle = '#73bf2e';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;

                    // Top Pipe
                    ctx.fillRect(p.x, 0, this.w, p.top);
                    ctx.strokeRect(p.x, -2, this.w, p.top + 2); // -2 to hide top border
                    
                    // Cap on Top Pipe
                    ctx.fillRect(p.x - 2, p.top - 20, this.w + 4, 20);
                    ctx.strokeRect(p.x - 2, p.top - 20, this.w + 4, 20);

                    // Bottom Pipe
                    ctx.fillRect(p.x, canvas.height - p.bottom, this.w, p.bottom);
                    ctx.strokeRect(p.x, canvas.height - p.bottom, this.w, p.bottom + 2);

                    // Cap on Bottom Pipe
                    ctx.fillRect(p.x - 2, canvas.height - p.bottom, this.w + 4, 20);
                    ctx.strokeRect(p.x - 2, canvas.height - p.bottom, this.w + 4, 20);
                }
            },

            update: function() {
                // Add new pipe
                if (frames % 110 === 0) {
                    const padding = 50;
                    const maxTop = groundY - this.gap - padding;
                    const minTop = padding;
                    const topHeight = Math.floor(Math.random() * (maxTop - minTop + 1) + minTop);
                    const bottomHeight = groundY - this.gap - topHeight;

                    this.items.push({
                        x: canvas.width,
                        top: topHeight,
                        bottom: bottomHeight,
                        passed: false
                    });
                }

                for(let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    p.x -= this.dx;

                    // Collision Detection
                    // Horizontal overlap
                    if (bird.x + bird.w > p.x && bird.x < p.x + this.w) {
                        // Vertical overlap (hit top or hit bottom)
                        if (bird.y < p.top || bird.y + bird.h > canvas.height - p.bottom) {
                            gameOver();
                        }
                    }

                    // Score Update
                    if (p.x + this.w < bird.x && !p.passed) {
                        score++;
                        scoreEl.innerText = score;
                        p.passed = true;
                        playSound('score');
                    }

                    // Remove off-screen pipes
                    if (p.x + this.w < 0) {
                        this.items.shift();
                        i--;
                    }
                }
            },
            
            reset: function() {
                this.items = [];
            }
        };

        const ground = {
            x: 0,
            h: 100,
            draw: function() {
                // Top border
                ctx.fillStyle = '#ded895';
                ctx.fillRect(0, groundY, canvas.width, this.h);
                
                // Grass top
                ctx.fillStyle = '#73bf2e';
                ctx.fillRect(0, groundY, canvas.width, 15);
                ctx.strokeStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(0, groundY);
                ctx.lineTo(canvas.width, groundY);
                ctx.stroke();

                // Moving pattern
                ctx.fillStyle = '#d0c874';
                for(let i = this.x; i < canvas.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, groundY + 15);
                    ctx.lineTo(i - 10, groundY + this.h);
                    ctx.lineTo(i + 2, groundY + this.h);
                    ctx.lineTo(i + 12, groundY + 15);
                    ctx.fill();
                }
            },
            update: function() {
                this.x -= 3;
                if (this.x <= -20) this.x = 0;
            }
        };

        // Loops
        function loop() {
            if (gameState !== 'PLAYING') return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            pipes.update();
            pipes.draw();
            
            ground.update();
            ground.draw();
            
            bird.update();
            bird.draw();
            
            frames++;
            requestAnimationFrame(loop);
        }

        function drawTitleScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ground.draw();
            bird.y = canvas.height / 2 - 20; 
            bird.draw();
            
            // Update the display on start screen
            startHighScoreEl.innerText = highScore;
        }

        // Controls
        function startGame() {
            score = 0;
            frames = 0;
            scoreEl.innerText = score;
            bird.y = 150;
            bird.velocity = 0;
            bird.rotation = 0;
            pipes.reset();
            
            gameState = 'PLAYING';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreEl.classList.remove('hidden');
            newBestBadge.classList.add('hidden');
            
            bird.jump(); // Initial jump
            loop();
        }

        function resetGame() {
            gameState = 'START';
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            scoreEl.innerText = 0;
            drawTitleScreen();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            playSound('hit');
            
            let isNewBest = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyHighScore', highScore);
                isNewBest = true;
            }
            
            finalScoreEl.innerText = score;
            bestScoreEl.innerText = highScore;
            
            // Show badge if new high score
            if (isNewBest && score > 0) {
                newBestBadge.classList.remove('hidden');
            } else {
                newBestBadge.classList.add('hidden');
            }
            
            scoreEl.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function inputAction(e) {
            if (e.type === 'keydown' && e.code !== 'Space') return;
            if (e.type === 'touchstart') e.preventDefault(); 

            if (gameState === 'PLAYING') {
                bird.jump();
            } else if (gameState === 'START' && e.target.tagName !== 'BUTTON') {
                startGame();
            }
        }

        // Event Listeners
        window.addEventListener('keydown', inputAction);
        window.addEventListener('mousedown', inputAction);
        window.addEventListener('touchstart', inputAction, {passive: false});

        // Init
        drawTitleScreen();

    </script>
</body>
</html>
